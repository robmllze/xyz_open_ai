//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// GENERATED BY XYZ_GEN - DO NOT MODIFY BY HAND
// See: https://github.com/robmllze/xyz_gen
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: annotate_overrides
// ignore_for_file: empty_constructor_bodies
// ignore_for_file: invalid_null_aware_operator
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_null_comparison
// ignore_for_file: unnecessary_this

part of 'model_message.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class ModelMessage extends _ModelMessage {
  //
  //
  //

  static const DEFAULT_DOC_PATH_PATTERN = "model_message_collection/{id}";

  static const K_ARGS = "args";
  static const K_CONTENT = "content";
  static const K_DOC_PATH_PATTERN = "doc_path_pattern";
  static const K_ID = "id";
  static const K_ROLE = "role";
  static const K_TIMESTAMP = "timestamp";

  String? content;
  String? role;
  int? timestamp;

  //
  //
  //

  ModelMessage({
    String? id,
    dynamic args,
    String? docPathPattern,
    this.content,
    this.role,
    this.timestamp,
  }) : super._() {
    this.id = id;
    this.args = args;
    this.docPathPattern = docPathPattern ?? DEFAULT_DOC_PATH_PATTERN;
  }

  //
  //
  //

  ModelMessage.unsafe({
    String? id,
    dynamic args,
    String? docPathPattern,
    this.content,
    this.role,
    this.timestamp,
  }) : super._() {
    this.id = id;
    this.args = args;
    this.docPathPattern = docPathPattern ?? DEFAULT_DOC_PATH_PATTERN;
  }

  //
  //
  //

  factory ModelMessage.from(ModelMessage other) {
    return ModelMessage.unsafe()..updateWith(other);
  }

  //
  //
  //

  factory ModelMessage.fromJMap(Map<String, dynamic> input) {
    try {
      return ModelMessage.unsafe(
        args: input[K_ARGS],
        content: input[K_CONTENT]?.toString().trim().nullIfEmpty,
        docPathPattern:
            input[K_DOC_PATH_PATTERN]?.toString().trim().nullIfEmpty,
        id: input[K_ID]?.toString().trim().nullIfEmpty,
        role: input[K_ROLE]?.toString().trim().nullIfEmpty,
        timestamp: letInt(input[K_TIMESTAMP]),
      );
    } catch (e) {
      assert(false, e);
      rethrow;
    }
  }

  //
  //
  //

  @override
  String getDocPath() {
    return this.docPathPattern?.inlineReplace(
              this.toJMap(),
              opening: "{",
              closing: "}",
            ) ??
        "";
  }

  //
  //
  //

  @override
  Map<String, dynamic> toJMap({
    dynamic defaultValue,
    bool includeNulls = false,
  }) {
    try {
      final withNulls = <String, dynamic>{
        K_ARGS: args,
        K_CONTENT: content?.toString().trim().nullIfEmpty,
        K_DOC_PATH_PATTERN: docPathPattern?.toString().trim().nullIfEmpty,
        K_ID: id?.toString().trim().nullIfEmpty,
        K_ROLE: role?.toString().trim().nullIfEmpty,
        K_TIMESTAMP: timestamp,
      }.mapWithDefault(defaultValue);
      return includeNulls ? withNulls : withNulls.nonNulls;
    } catch (e) {
      assert(false, e);
      rethrow;
    }
  }

  //
  //
  //

  @override
  T empty<T extends Model>() {
    return ModelMessage.unsafe() as T;
  }

  //
  //
  //

  @override
  T copy<T extends Model>() {
    return (ModelMessage.unsafe()..updateWith(this)) as T;
  }

  //
  //
  //

  @override
  T copyWith<T extends Model>(T other) {
    if (other is ModelMessage) {
      return this.copy()..updateWith(other);
    }
    assert(false);
    return this.copy() as T;
  }

  //
  //
  //

  @override
  T copyWithJMap<T extends Model>(JMap other) {
    if (other.isNotEmpty) {
      return this.copy()..updateWithJMap(other);
    }
    return this.copy() as T;
  }

  //
  //
  //

  @override
  void updateWith<T extends Model>(T other) {
    if (other is ModelMessage) {
      this.args = other.args ?? this.args;
      this.content = other.content ?? this.content;
      this.docPathPattern = other.docPathPattern ?? this.docPathPattern;
      this.id = other.id ?? this.id;
      this.role = other.role ?? this.role;
      this.timestamp = other.timestamp ?? this.timestamp;
    } else {
      assert(false);
    }
  }

  //
  //
  //

  @override
  void updateWithJMap<T extends Model>(JMap other) {
    this.updateWith(ModelMessage.fromJMap(other));
  }
}
